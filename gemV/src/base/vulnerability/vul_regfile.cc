/*
 * Copyright (c) 20014-15 Arizona State University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Srinivas Tanikella
 *
 *	    Compiler and Microarchitecture Lab, ASU
 * 	    http://aviral.lab.asu.edu
 */

#include "base/vulnerability/vul_regfile.hh"
#include "debug/VulTracker.hh"

RegVulCalc::RegVulCalc(int numRegs, int fi_reg)
{
    this->numRegs = numRegs;
    this->fi_reg = fi_reg;

    writesInList = (int *)malloc(sizeof(int)*numRegs);
    hist.resize(numRegs);

    // Hack. Will have to find a better way around. 
    // Initially, registers 13, 0, 1, 2 are set directly. So,
    // the corresponding vulOnRead and vulOnWrite functions are not called.
    // Calling them manually here.
    for(int i = 0; i < numRegs; ++i) {

        writesInList[i] = 0;
        this->vulOnWrite(i, 0);
    }

    Callback *cb = new MakeCallback<RegVulCalc, &RegVulCalc::exitCallback>(this);
    registerExitCallback(cb);
     
}

RegVulCalc::~RegVulCalc()
{

}

void
RegVulCalc::vulOnRead(int idx, int seqNum)
{
    assert(idx < numRegs);

    if(idx == 33)
        return;

    //if(writesInList[idx] == 0)
    //    return;

    History h;
    h.op = READ;
    h.t = curTick();
    h.seqNum = seqNum;

    hist[idx].push_back(h);
    DPRINTF(VulTracker, "Vultracker: [sn: %i]: Read to register %d, tick %ld\n", seqNum, idx, h.t);

}

void 
RegVulCalc::vulOnWrite(int idx, int seqNum)
{
    assert(idx < numRegs);

    if(idx == 33)
        return;

    DPRINTF(VulTracker, "Vultracker: [sn: %i]: Write to register %d, tick %ld\n", seqNum, idx, curTick());
    // If write already in list, accumulate vulnerability and then empty the list.
    if(writesInList[idx] > 0) {

        Operation prev_op = INVALID;
        Tick prev_t = -1;

        std::list<History>::iterator hit = hist[idx].begin();

        // First access should always be a WRITE
        assert(hit->op == WRITE);

        prev_t = hit->t;
        prev_op = hit->op;
        while(hit != hist[idx].end()) {

            if(hit->op == READ && (prev_op == READ || prev_op == WRITE)) { 
                    vul += REGISTER_WIDTH*(hit->t - prev_t)/TICKS_PER_CYCLE;
                    if(idx == fi_reg)
                        DPRINTF(VulTracker, "[sn: %i]: Phys register %d vulnerable from tick %lu to %lu\n", 
                                                        seqNum, idx, prev_t, hit->t);

            }
            
            prev_t = hit->t;
            prev_op = hit->op;            

            hit++;
        }
        writesInList[idx] = 0;
    }

    hist[idx].clear();
    
    History h;
    h.op = WRITE;
    h.incomingTick = curTick();
    h.t = curTick();
    h.seqNum = seqNum;

    hist[idx].push_back(h);

    writesInList[idx]++;
}

void
RegVulCalc::clearSquashedAccess(int seqNum)
{
    for(int i = 0; i < numRegs; ++i) {

        std::list<History>::iterator hit = hist[i].begin();

        if(hit == hist[i].end())
            continue;

        //assert(hit->op == WRITE);
        //if(hit->op == WRITE)
        //    DPRINTF(VulTracker, "Vultracker: Clear: [sn: %i] idx: %d WRITE\n", seqNum, i);
        //else if(hit->op == READ)
        //    DPRINTF(VulTracker, "Vultracker: Clear: [sn: %i] idx: %d READ\n", seqNum, i);
        //else
        //    DPRINTF(VulTracker, "WTF!!\n");

        while(hit != hist[i].end()) {

            if(hit->seqNum == seqNum) {
                DPRINTF(VulTracker, "Vultracker: Clear: [sn: %i] register %d clearing seqnum %i op %d\n", seqNum, i, hit->seqNum, hit->op);
                if(hit->op == WRITE)
                    --writesInList[i];
                hit = hist[i].erase(hit);
            }
            else
                hit++;
        }
    }
}

void
RegVulCalc::exitCallback()
{
    for(int idx = 0; idx < numRegs; ++idx) {

        if(!hist[idx].empty()) {

            std::list<History>::iterator hit = hist[idx].begin();

            Tick prev_t = hit->t;
            Operation prev_op = hit->op;

            while(hit != hist[idx].end()) {
                
                if(hit->op == READ && (prev_op == READ || prev_op == WRITE)) {
                    
                    vul += REGISTER_WIDTH*(hit->t - prev_t)/TICKS_PER_CYCLE;
                    DPRINTF(VulTracker, "[sn: %i]: Phys Register %d vulnerable from tick %lu to %lu cleanup\n", 
                                                        hit->seqNum, idx, prev_t, hit->t);
                }  
                
                prev_t = hit->t;
                prev_op = hit->op;               

                hit++;
            }

        }

    }
}

void
RegVulCalc::regStats()
{
    using namespace Stats;

    vul
        .name("vulnerability.register_file")
        .desc("Register file vulnerabiilty in bit-cycles");

}


